# IO网络编程
## Linux操作系统及组成
1.操作系统的作用
>操作系统(OS)是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。  

2.Linux操作系统组成
>一个典型的Linux操作系统组成为：Linux内核、文件系统、命令行shell、图形界面和桌面环境、并包扩各种工具和应用软件。
>* Linux内核：Linux系统的核心代码  
>* 文件系统：通常指称管理磁盘数据的系统，可将数据以目录或文件的形式存储。每个文件系统都有自己的特殊格式与功能  
>* shell命令：接收用户命令，然后调用相应的应用程序，并根据用户输入的指令来反馈给用户指定的信息。 

![Linux系统模型图](Linux系统模型图.jpg)
## shell命令
### 文件操作命令
* Linux下的目录结构  
![Linux目录结构图](Linux目录结构图.jpg)
|作用|命令|
|----|----|
|切换工作目录|cd|
|查看文件|ls, ls -l,ls -a|
|复制文件|cp -r|
|移动文件|mv|
|删除文件|rm -rf,rmdir|
|创建文件夹|mkdir -p|
|创建文件|touch|
|查看文件内容|cat|
## IO
1.定义  
>在内存中存在数据交换的操作认为是IO操作，比如和终端交互、磁盘交互、和网络交互等

2.程序分类
>* IO密集型程序:在程序执行中有大量的IO操作，而cpu运算较少。消耗cpu较少，耗时长。
>* 计算密集型程序:程序运行中计算较多，IO操作相对较少,cpu消耗多，执行速度快，几乎没有阻塞。
## 文件
文件是保存在持久化存储设备(硬盘、U盘、光盘)上的一段数据。从功能角度分为文本文件(打开后会自动解码为字符)、二进制文件(视频、音频等)。在Python里把文件是做一种类型的对象，类似之前学习过的其他类型。
## 字节串(bytes)
在python3中引入了字节串的概念，与str不同，字节串以字节序列值表达数据，更方便用来处理二进制数据。因此在python3中字节串是常见的二进制数据展现方式。
* 普通的ASCII编码字符串可以在前面加b转换为字节串，例如b'hello'
* 字符串转换为字节串的方法:str.encode()
* 字节串转换为字符串的方法:bytes.decode()
## 文件读写
对文件实现读写的基本操作步骤为:打开文件、读写文件、关闭文件  
**代码实现：day04/file_open.py**
```python
"""
file_open.py
打开方式训练
"""
# 打开文件
try:
    # fd = open("a.py",'r')   # 以只读方式打开
    # fd = open("a.py",'w')     # 以只写方式打开
    # fd = open("a.py", 'a')  # 以追加方式打开
    """
    普通的文本文件 
    既可以使用文本方式打开也可以使用二进制方式打开
    二进制文件必须以二进制方式打开
    """
    fd = open("a.py", 'rb')  # 以二进制只写方式打开
    print(fd)
except Exception as e:
    print(e)
# 读写文件

# 关闭文件
fd.close()
```  
**代码实现：day04/file_read.py**
```python
"""
file_read.py
文件读取演示
"""
# 打开文件
f = open('test.txt','r')
# read循环读取
# while True:
#     # 读到文件结尾返回空字符串
#     data = f.read(100)  # 每次最多读100个字符
#     if not data:    # 读到结尾跳出循环
#         break
#     print(data)

# 读取一行内容
# data = f.readline(10)   # 读取前10个字符
# print(data)
# data = f.readline()     # 读完第一行剩余内容
# print(data)

# 将内容读取为列表，每行为列表一个元素
# data = f.readlines(18)    # 前18个字节所在的行作为读取对象
# print(data)

# f为可迭代对象
for line in f:
    print(line)     # 每次迭代到一行内容
# 关闭
f.close()
```
**代码实现：day04/file_write.py**
```python
"""
file_write.py
文件写操作演示
"""
# 打开文件
f = open('test.txt','a')
# f = open('image.jpg','ab')
# 写操作
# f.write("hello 死鬼\n".encode())
# f.write("哎呀，干啥".encode())

# 将列表写入 需要人为的添加换行
# l = ['hello world\n','哈哈哈\n']
f.write("董浩东")
f.close()

```
### 1.打开文件
```
file_object = open(file_name,access_mode='r',buffering=-1)
功能：打开一个文件，返回一个文件对象。
参数：file_name 文件名
     access_mode 打开文件的方式，如果不写默认为'r'
```
|文件模式|操作|
|-------|----|
|r|以读方式打开，文件必须存在|
|w|以写方式打开文件不存在则创建，存在则清空原有内容|
|a|以追加模式打开|
|r+|以读写模式打开文件必须存在|
|w+|一读写莫斯打开文件不存在则创建，存在则清空原有内容|
|a+|以读写模式打开追加模式|
|rb|以二进制读模式打开同r|
|wb|以二进制写模式打开同w|
|ab|以二进制追加模式打开同a|
|rb+|以二进制读写模式打开同r+|
|wb+|以二进制读写模式打开同w+|
|ab+|以二进制读写模式打开同a+|
buffering 1表示有行缓冲，默认则表示使用系统默认提供的缓冲机制。返回文件操作对象。
>缓冲：系统自动的在内存中为每个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，再由缓冲区送到磁盘中去。从磁盘中读取数据，则依次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区将数据送到程序的数据区。

### 2.读取文件
>read([size])
功能：用来直接读取文件中字符。  
参数：如果没有给定size参数(默认值为-1)或者size值为负，文件将被读取直至末尾，给定size最多读取给定数目个字符(字节)。  
返回值：返回读到的内容。
>* 注意：文件过大时候不建议直接读取到文件结尾，读到文件结尾会返回空字符串。

>readline([size])
功能：用来读取文件中一行  
参数：如果没有给定size参数(默认值为-1)或者size值为负，表示读取下一行，给定size表示最多读取指定的字符(字节)。  
返回值：返回读取到的内容 

>readlines([size])
功能：读取文件中的每一行作为列表中的一项
参数：如果没有给定size参数(默认值为-1)或者size值为负，文件将被读取直至末尾，给定size表示读取到size字符所在行行停止。  
返回值：返回读取到的内容列表

>文件对象本身也是一个可迭代对象，在for循环中可以迭代文件的每一行。
```python
for line in f:
    print(line)
```
### 3.写入文件
write(string)
功能：把文本数据或二进制数据块的字符串写入到文件中去  
参数：要写入的内容
* 如果需要换行要自己在写入内容中添加\n  

writelines(str_list)
功能：接受一个字符串列表作为参数，将它们写入文件。  
参数：要写入的内容列表  
## 4.关闭文件 
打开一个文件后我们就可以通过文件对象对文件进行操作了，当操作结束后使用 close()关闭这个对象可以防止一些误操作，也可以节省资源。  
file_object.close()
## with操作
python中with语句使用于对资源进行访问的场合，保证不管处理过程中是否发生错误或者异常都会执行规定的“清理操作”，释放被访问的资源，比如有文件读写后自动关闭、线程中锁的自动获取和释放等。  
with语句的语法格式如下: 
```python
with context_expression [as target(s)]:
    with body
```
通过with方法可以不用close(),因为with生成的对象在语句块结束后会自动处理，所以也就不需要close了，但是这个文件对象只能在with语句块内使用
```python
with open('file','r+') as f:
    f.read()
```
>注意
>>1.加b的打开方式要求必须都是字符串  
2.无论怎么缓冲，当程序结束或者文件被关闭时都会将缓冲区内容写入磁盘。
## 文件偏移量
**代码实现：day05/seek.py**
```python
```
### 1.定义
打开一个文件进行操作时系统会自动生成一个记录，记录中描述了我们对文件的一系列操作。其中包括每次操作到的文件位置。文件读写操作都是从这个位置开始进行的。
### 2.基本操作
>tell()  
功能：获取文件偏移量大小 

>seek(offset[,whence])
功能：移动文件偏移量位置
参数：offset代表相对于某个位置移动的字节数。负数表示向前移动，正数表示向后移动。  
whence是基准位置的默认值为0，代表从文件开头算起，1代表从当前位置算起，2代表从文件末尾算起。
>* 必须以二进制方式打开文件时基准位置才能是1或者2
## 文件描述符
### 1.定义
系统中每一个IO操作都会分配一个整数作为编号，该整数即这个IO操作的文件描述符  
### 2.获取文件描述符。
fileno()  
通过IO对象获取对应的文件描述符
### 3.文件管理函数
1.获取文件大小
>os.path.getsize(file)

2.查看文件列表
>os.listdir(dir)

3.查看文件是否存在
>os.path.exists(file)

4.判断文件类型
>os.path.isfile(file)

5.删除文件
>os.remove(file)
# 网络编程基础
计算机网络功能主要包括实现资源共享，实现数据信息的快速传递。  
## OSI七层模型
指定组织：ISO(国际标准化组织)  
作用：使网络通信工作流程标准化  
应用层：提供用户服务，具体功能有应用程序实现  
表示层：数据的压缩优化加密  
会话层：简历用户级的连接，选择适当的传输服务  
传输层：提供传输服务  
网络层：路由选择，网络互联  
链路层：进行数据交换，控制具体数据的发送  
物理层：提供数据传输的硬件保证，网卡接口，传输介质  
优点  
* 建立了统一的工作流程  
* 分部清晰，各司其职，每个步骤分工明确
* 降低了各个模块之间的耦合度，便于开发  
## 四层模型(TCP/IP模型)
背景：实际工作中工程师无法完全按照七层模型要求操作，逐渐演化为更符合实际情况的四层模型  
![网络互联模型对照](网络互联模型对照.jpg)
## 数据传输过程
1.发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。  
2.发送的消息经过多个节点(交换机、路由器)传输，最终到达目标主机。  
3.目标主机由物理层逐渐解析首部消息包，最终到应用程序呈现消息。  
![数据传输过程](数据传输过程图.jpg)
![数据传输过程示意图](数据传输过程示意图.jpg)
### 网络协议
>在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等。
## 网络基础概念
* IP地址
>功能：确定一台主机的网络路由位置

> 查看本机网络地址命令:  
Windows/ipconfig  
Linux/ifconfig

>结构
>>IPv4 点分十进制表示127.0.0.1每个部分取值范围0-255  
IPv6 128位扩大了地址范围  

* 域名
>定义：给网络服务器地址起个名字  

>作用：方便记忆，表达一定的含义

>ping [ip]:测试和某个主机是否联通  

* 端口号
>作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序。

>特点：一个系统中的应用监听端口不能重复

>取值范围：1-65535
>>1-1023系统应用或者大众程序监听端口
1024-65535自用端口

## 传输层服务
### 面向连接的传输服务(基于TCP协议的数据传输)
1.传输特征：提供了可靠地数据传输，可靠性指数据传输过程中无丢失，无失序，误差错，无重复。  
2.实现手段：在通信前需要建立数据连接，通信结束要正常断开连接。
>三次握手(建立连接)
>>客户端向服务器发送消息报文请求连接  
>>服务器收到请求后，同时回复报文确定可以连接  
>>客户端收到回复，发送最终报文连接建立

![三次握手](三次握手.jpg)
>四次挥手(断开连接)
>>主动方发送报文请求断开连接  
>>被动方收到请求后，立即回复，表示准备断开  
>>被动方准备就绪，再次发送报文表示可以断开  
>>主动方收到确定，发送最终报文完成断开  

![四次挥手](四次挥手.jpg)
3.使用情况：对数据传输确定性有明确要求，传输文件较大，需要确保可靠性的情况。比如：网页获取，文件下载，邮件收发。
### 面向无连接的传输服务(基于UDP协议的数据传输)
1.传输特点：不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。  
2.适用情况：网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播  
**面试要求**
* OSI七层介绍一下，tcp/ip模型是什么？
* tcp服务和udp服务有什么区别？
* 三次握手和四次挥手指什么，过程是怎样的？
# socket套接字
## 套接字介绍
1.套接字：实现网络编程进行数据传输的一种技术手段  
2.Python实现套接字编程：import socket  

3.套接字分类
>流式套接字(SOCK_STREAM):以字节流方式传输数据，实现tcp网络传输方案。(面向连接--tcp协议--可靠的--流式套接字)

>数据报套接字(SOCK_DGRAM)：以数据报形式传输数据，实现udp网络传输方案。(无连接--udp协议--不可靠--数据报套接字)
## tcp套接字编程
### 服务端流程
![服务器端流程](服务器端流程.jpg)
**代码实现day05/tcp_server**
```python
"""
tcp_server.py tcp套接字服务端流程
重点代码

注意：功能性代码，注重流程和函数使用
"""
import socket

# 创建tcp套接字
sockfd = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

# 绑定地址
sockfd.bind(('127.0.0.1',8888))

# 设置监听
sockfd.listen(5)

# 阻塞等待处理连接
print("Waiting for connect......")
connfd, address = sockfd.accept()
print("Connect from",address)  # 打印连接的客户端地址

# 收发消息
data = connfd.recv(1024)
print("收到：",data)
n = connfd.send(b'Thanks')  # 发送字节串
print("发送{}字节".format(n))

# 关闭套接字
connfd.close()
sockfd.close()
```
#### 1.创建套接字
```
sockfd=socket.socket(socket_family=AF_INET,socket.type=SOCK_STREAM,proto=0)
功能：创建套接字
参数：socket_family 网络类型 AF_INET表示ipv4
socket_type 套接字类型
SOCK_STREAM(流式) SOCK_DGRAM(数据报) proto 通常为0，选择子协议
返回值：套接字对象
```
#### 2.绑定地址
>本地地址:'localhost','127.0.0.1'  
网络地址:'192.168.43.54'  
自动获取地址:'0.0.0.0'  

![地址绑定](地址绑定.jpg)
```
sockfd.bind(address)
功能：绑定本地网络地址
参数：二元元组(ip,port)('0.0.0.0',8888)
```
#### 3.设置监听
```
sockfd.listen(n)
功能：将套接字设置为监听 套接字，确定监听队列大小
参数：监听队列大小
```
#### 4.等待处理客户连接请求
```
connfd.address = sockfd.accept()
功能：阻塞等待处理客户端请求
返回值：connfd 客户端连接套接字
       address 连接客户端地址
```
#### 5.消息收发
```
data = connfd.recv(buffersize)
功能：接受客户端消息
参数：每次最多接收消息的大小
返回值 ：接收到的内容
 
n = connfd.send(data)
功能：发送消息
参数：要发送的内容 bytes格式
返回值：发送的字节数
```
#### 6.关闭套接字
```
sockfd.close()
功能：关闭套接字
```
### 客户端流程
![客户端流程](客户端流程.jpg)
**代码实现：day05/tcp_client.py**
```python
"""
tcp_client.py tcp客户端流程
"""
from socket import *

# 创建tcp套接字
sockfd = socket()     # 使用默认参数-->tcp套接字

# 连接服务器
server_address = ('127.0.0.1',8888)     # 服务端地址
sockfd.connect(server_address)

# 发送消息
data = input("Msg>>")
sockfd.send(data.encode())      # 转换为字节串再发送
data = sockfd.recv(1024)
print("Server:",data.decode())       # 打印接收内容

# 关闭套接字
sockfd.close()
```
#### 1.创建套接字
>注意:只有相同类型的套接字才能进行通信
#### 2.请求连接
> sockfd.connect(server_address)  
功能：连接服务器   
参数：元组  服务器地址
#### 3.收发消息
>注意：防止两端都阻塞，recv/send要配合
#### 4.关闭套接字
### 套接字数据传输特点
>* tcp连接中当一段退出，另一端如果阻塞在recv，此时recv会立即返回一个空字符串。  
>* tcp连接中如果一端已经不存在，仍然试图通过send发送则会产生BrokenPipeError
>* 一个监听套接字可以同时连接多个客户端，也能够重复被连接  
### 网络收发缓冲区
1.网络缓冲区有效的协调了消息的收发速度  
2.send和recv实际是向缓冲区发送接收消息，当缓冲区部位空recv就不会阻塞。
### tcp粘包
**代码示例day06/stick_send.py,stick_recv.py**
```python
from socket import *
from time import sleep

# 创建tcp套接字
sockfd = socket()     # 使用默认参数-->tcp套接字

# 连接服务器
server_address = ('127.0.0.1',8889)     # 服务端地址
sockfd.connect(server_address)

while True:
    sleep(0.3)
    sockfd.send(b"msg")


```
```python
"""
粘包演示
"""
from socket import *
from time import sleep

# 创建tcp套接字
sockfd = socket()

# 绑定地址
sockfd.bind(('0.0.0.0',8889))

# 设置监听
sockfd.listen(5)

connnfd,address = sockfd.accept()

while True:
    sleep(1)
    data = connnfd.recv(1024)
    print(data.decode())
```
>原因：tcp以字节流方式传输，没有消息边界，多次发送的消息被一次接收，此时会形成粘包。  

>影响：如果每次发送内容是一个独立的含义，需要接收端独立解析时粘包会有影响。  

>处理方法
>>1.人为的添加消息边界  
>>2.控制发送速度  
## UDP套接字编程
### 服务端流程 
![udp服务端流程](udp服务端流程.jpg)
**代码实现:day06/udp_server.py**
```python
"""
upd_server.py udp套接字服务器端流程
"""
from socket import *

# 创建套接字
sockfd = socket(AF_INET,SOCK_DGRAM)

# 绑定地址
server_address = ('127.0.0.1',8888)
sockfd.bind(server_address)

# 收发消息
while True:
    data,address = sockfd.recvfrom(1024)
    print("收到消息：",data.decode())
    sockfd.sendto(b'Thanks',address)
# 关闭套接字
sockfd.close()
```
#### 1.创建数据报套接字
>sockfd = socket(AF_INET,SOCK_DGRAM)  
#### 2.绑定地址
>sockfd.bind(address)  
#### 3.消息收发
```
data,address = sockfd.recvfrom(buffersize)  
功能：接收UDP消息  
参数：每次最多接收多少个字节  
返回值：data 接收到的内容  
       address 消息发送方地址

n = sockfd.sendto(data,address)  
功能：发送UDP消息  
参数：data 发送的内容 bytes格式  
     address 目标地址  
返回值：发送的字节数  
```
#### 4.关闭套接字
>sockfd.close()
### 客户端流程
![udp客户端流程](udp客户端流程.jpg)
**代码实现：day06/udp_client.py**
```python
"""
udp_client.py   udp客户端流程
"""
from socket import *

# 创建套接字
sockfd = socket(AF_INET,SOCK_DGRAM)

# 服务器地址
ADDRESS = ('127.0.0.1',8888)
# 循环收发消息
while True:
    data = input("Msg>>")
    if not data:
        break
    sockfd.sendto(data.encode(),ADDRESS)
    msg,address = sockfd.recvfrom(1024)
    print("From server:",msg.decode())
sockfd.close()
```
>总结：tcp套接字和udp套接字编程区别  
>> 1.流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输  
>> 2.tcp套接字会有粘包，udp套接字有消息边界不会粘包  
>> 3.tcp套接字保证消息的完整性，udp套接字不会保证消息完整性  
>> 4.tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要  
>> 5.tcp套接字使用send,recv收发消息，udp套接字使用sendto，recvfrom 
## socket套接字属性
**代码实现:day06/sock_attr.py**
```python
"""
套接字属性介绍
"""
from socket import *

# 创建套接字
s = socket()
s.bind(("127.0.0.1",8888))
s.listen(3)
c,address=s.accept()

print("地址类型：",s.family)
print("套接字类型：",s.type)
print("绑定地址：",s.getsockname())
print("文件描述符：",s.fileno())
# 连接套接字调用 结果同accept返回的address
print("连接端地址：",c.getpeername())

```
【1】sockfd.type 套接字类型  
【2】sockfd.family 套接字地址类型  
【3】sockfd.getsockname() 获取套接字绑定地址
【4】sockfd.fileno() 获取套接字的文件描述符  
【5】sockfd.getpeername() 获取连接套接字客户端地址  
【6】sockfd.setsockopt(level,option,value)  
功能：设置套接字选项  
参数：level 选项类别 SOL_SOCKET  
option 具体选项内容  
value 选项值  
【7】sockfd.getsockopt(level,option)  
功能：获取套接字选项值
|选项|意义|期望值|
|----|---|------|
|SO_BINDTODEVICE|可以使socket只在某个特殊的网络接口(网卡)有效。也许不能是移动便携设备|一个字符串给出设备的名称或者一个空字符串返回默认值|
|SO_BROADCAST|允许广播地址发送和接收信息包。只对UDP有效。如何发送和接收广播信息包|布尔型整数|
|SO_DONTROUTE|禁止通过路由器和网关往外发送信息包。这主要是为了安全而用在以太网上UDP通信的一种方法。不管目的地址使用什么IP地址，都可以防止数据离开本地网络|布尔型整数|
|SO_KEEPALIVE|可以使TCP通信的信息包保持连续性。这些信息包可以在没有信息传输的时候，使通信双方确定连接是保持的|布尔型整数|
|SO_OOBINLINE|可以把收到的不正常数据看成是正常的数据，也就是说会通过一个标准的对recv()的调用来接收这些数据|布尔型整数|
|SO_REUSEADDR|当socket关闭后，本地端用于该socket的端口号立刻就可以被重用。通常来说，只有经过系统定义一段时间后，才能被重用。|布尔型整数|
## UDP套接字广播
**代码实现：day06/broadcast_recv.py**
```python
"""
广播接收
1.创建udp套接字
2.设置套接字可以发送接收广播 (setsockopt)
3.选择接收的端口
4.接收广播
"""
from socket import *
s = socket(AF_INET,SOCK_DGRAM)

# 设置套接字接收广播
s.setsockopt(SOL_SOCKET,SO_BROADCAST,1)
s.bind(('0.0.0.0',9999))
while True:
    msg,address = s.recvfrom(1024)
    print(msg.decode())


```
**代码实现：day06/broadcast_send.py**
```python
"""
广播发送
1.创建udp套接字
2.设置可以发送广播
3.循环向广播地址发送
"""
from socket import *
from time import sleep
# 广播地址
dest = ('127.0.0.255',9999)

s = socket(AF_INET,SOCK_DGRAM)

s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)

data = """
**************************
    西安  10.12  深秋
    温度：  30℃
    状态：  没有四块五的妞
**************************
"""
while True:
    sleep(2)
    s.sendto(data.encode(),dest)    # 目标地址=广播地址
```
* 广播定义：一次发送，多点接收
* 广播地址：每个网络的最大地址为发送广播的地址，向该地址发送 ，则网段内所有主机都能接收。  
## TCP套接字之HTTP传输  
### HTTP协议(超文本传输协议)
1. 用途：网页获取，数据传输
2. 特点
>* 应用层协议，传输层使用tcp传输
>* 简单,灵活,很多语言都有HTTP专门接口
>* 无状态，协议不记录传输内容
>* http1.1 支持持久连接，丰富了请求类型  

3.网页请求过程
>1.客户端(浏览器)通过tcp传输，发送http请求给服务  
>2.服务端接收到http请求后进行解析  
>3.服务端处理请求内容，组织响应内容  
>4.服务端将响应内容以http响应格式发送给浏览器  
>5.浏览器接收到响应内容，解析展示  

![网页请求图](网页请求图.jpg)
![网页请求过程](网页请求过程.jpg)

## HTTP请求(request)
**代码实现：day06/http_test.py**
```python
```
**代码实现：day06/http_server.py**
```python
```
* 请求行：具体的请求类别和请求内容    
|Get|/|HTTP/1.1|
|---|---|------|
|请求类别|请求内容|协议版本|
请求类别：每个请求类别表示要做不同的事情
|类型|功能|
|----|----|
|GET|获取网络资源|
|POST|提交一定的信息，得到反馈|
|HEAD|只获取网络资源的响应头|
|PUT|更新服务器资源|
|DELETE|删除服务器资源|
|CONNECT||
|TRACE|测试|
|OPTIONS|获取服务器性能信息|
* 请求头：对请求的进一步解释和描述  
>Accept-Encoding:gzip
* 空行
* 请求体：请求参数或者提交内容  
## http响应(response)
1.响应格式：响应行，响应头，空行，响应体
* 响应行：反馈基本的响应情况
|HTTP/1.1|200|OK|
|--------|---|--|
|版本信息|响应码|附加信息|
响应码：
>1xx    提示信息，表示请求被接收  
>2xx    响应成功  
>3xx    响应需要进一步操作，重定向  
>4xx    客户端错误  
>5xx    服务器错误
* 响应头：对响应内容的描述
>Con-Tpye:text/html
* 响应体：响应的主题内容信息
# struct模块的使用
**代码实现：day07/struct_recv.py**
```python
```
**代码实现：day07/struct_send.py**
```python
```
1.原理：将一组简单数据进行打包，转换为bytes格式发送。或将一组bytes格式数据，进行解析。
2.接口使用
```
Struct(fmt)
功能：升恒结构化对象
参数：fmt 定义的数据结构

st.pac(v1,v2,v3,……)
功能：将一组数据按照指定格式打包转换为bytes
参数：要打包的数据
返回值：bytes字符串

st.unpack(bytes_data)
功能：将bytes字节串按照指定的格式解析
参数：要解析的字符串
返回值：解析后的内容

stuck.pack(fmt,v1,v2,v3.....)
struct.unpack(fmt,bytes_data)
```
>说明：可以使用struct模块直接调用pack,unpack。此时这两函数第一个参数传入fmt。其他用法功能相同

|Format|C Type|Python type|Standard size|Node|
|------|------|-------|-------|------|
|x|pad byte|no value|1||
|c|char|bytes of lenght 1|1||
|b|signed char|integer|1|(1).(3)|
|B|unsigned char|integer|1|(3)|
|?|_Bool|bool|1|(1)|
|h|short|integer|2|(3)|
|H|unsigned short|integer|2|(3)|
|i|int|integer|4|(3)|
|I|unsigned int|integer|4|(3)|
|l|long|integer|4|(3)|
|L|unsigned long|integer|4|(3)|
|q|long long|integer|8|(2),(3)|
|Q|unsigned long long|integer|8|(2),(3)|
|n|ssize_t|integer||(4)|
|N|size_t|integer||(4)|
|
|e|(7)|float|2|(5)|
|f|float|float|4|(5)|
|d|double|float|8|(5)|
|char[]|bytes|||
# HTTPServer
**参考代码:HTTPServer**
## 功能:
> http部分
>> 获取http请求
>> 解析http请求
>> 将请求发送给WebFrame
>> 将数据组织为Response格式发送给客户端

>WebFrame部分
>>从httpserver接收具体请求
>>根据请求进行逻辑处理和数据处理
>>将需要的书反馈给httpserver

>特点
>>采用httpserver和应用处理分离的模式降低了耦合度
>>采用了用户配置文件的思路
>webframe部分采用了模拟后端框架的处理方法

>技术点
>>httpserver部分需要两端建立通信
>>webframe部分采用多路复用接受并发请求
>>数据传递使用json格式

项目结构:
![项目结构](项目结构.jpg)
> 数据交互格式协议  
![交互数据格式协议](交互数据格式协议.jpg)
